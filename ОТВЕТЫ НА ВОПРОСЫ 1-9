1)Синтаксис указателя на функцию

тип_возврата имя_указателя тип_аргумента1 тип_аргумента2 и так далее)
тип_возврата что функция возвращает например это может быть, int, void, double
имя_указателя имя вашего указателя на функцию звёздочка нужна
тип_аргумента1, тип_аргумента2,  какие данные функция принимает например, int, double, char

2)Упрощение using

using FuncPtr = int (*)(int, int); // FuncPtr это кочрое тип указателя на функцию
FuncPtr myFuncPtr; // используем тут FuncPtr
using создает псевдоним для сложного типа и этим самым  делая код чище

3)Применение указателей на функции

передача логики как аргумент = это короче задает поведение функции вызывая новую 
выбор функции во время выполнения = определить какую функцию вызывать в зависимости от условий
реализация обратных вызовов = для обработки событий 

и вот короче апмер на коде

void process(int x, int y, int (*operation)(int, int)) {
   int result = operation(x, y); // тута вызываем переданую функцию
   //...
}
int add(int a, int b) { return a + b; }
process(1,2,add); // а вот тута передаем функцию add как параметр

4)захват переменных в лямбдах

[=] = захват по значению лямбда создает копии переменных из внешней области видимости
[&] = захват по ссылке лямбда использует ссылки на переменные из внешней области видимости

ну и вот короче пример на коде

 int x = 10;
 auto byValue = [=]() { std::cout << x; }; 
 auto byRef = [&]() { std::cout << x; };   
 x = 20; // меняем x
 byValue(); // тут выведет 10 (иммеется в виду копию)
 byRef();  // а тут выведет 20 (это ссылка)

5)Явное указание возвращаемого типа лямбды

это короче нужно если тип нельзя вывести автоматически
и вот вроде как это сделать 
auto lambda = [](int x) -> double { return x * 1.5; };

6)Лямбды в STL алгоритмах

std::sort: это нада для кастомизации порядка сортировки

вот пример на коде:
std::vector<int> vec = {3, 1, 4, 2};
std::sort(vec.begin(), vec.end(), [](int a, int b){ return a > b; }); // тут обратная сортировка

std::for_each: а вот эта для применения операции к каждому элементу

вот пример на коде
std::vector<int> vec = {1, 2, 3};
 std::for_each(vec.begin(), vec.end(), [](int x){ std::cout << x*2;}); // тут просто умножаем на 2

7)std::function

его предназначение = ну в кратце это просто тип для хранения любых вызываемых объектов функций лямбд и все такое 
а вот и отличие от указателя на функцию = std::function может хранить объекты с состоянием ну имею ввиду лямбды с захватом а указатели на функции не могут вот и все 

8) Сигнатура std::function

вот как это ваще выглядит
std::function<тип_возврата(тип_аргумента1, тип_аргумента2, ...)> имя_объекта;
пример на коде 
std::function<int(int, int)> myFunc;

9)Захват переменных в лямбдах и std::function

std::function может хранить лямбды с захватом переменных по значению ну или же по ссылке
указатели на функции не могут хранить контекст (захват переменных) так как они указывают только на код


вот и все,было додго и тяжеловато но надеюсь все сделал как надо
